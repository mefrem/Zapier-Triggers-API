# Story 1.3: Implement Authentication and Authorization

**Status:** Approved

---

## Story

**As a** Platform Administrator,
**I want** to secure the Triggers API with authentication,
**so that** only authorized developers can send events to Zapier.

---

## Acceptance Criteria

1. API key generation system implemented using AWS Secrets Manager
2. API Gateway custom authorizer validates API keys on all requests
3. Unauthorized requests return 401 Unauthorized
4. Rate limiting implemented (1000 requests per minute per API key)
5. Rate limit exceeded returns 429 Too Many Requests
6. API key management UI integrated with Zapier developer console
7. Documentation created for API key generation and usage

---

## Tasks / Subtasks

- [ ] Task 1: Implement API Key Data Model and DynamoDB Table (AC: 1)
  - [ ] Create APIKey Pydantic model in `services/api/src/models/api_key.py` with all required attributes (key_id, user_id, key_hash, name, created_at, last_used_at, expires_at, rate_limit, is_active, scopes)
  - [ ] Create DynamoDB table `zapier-triggers-api-keys-{env}` via Terraform with partition key (user_id) and sort key (key_id)
  - [ ] Create GSI-1: KeyHashIndex for API key lookups during authentication
  - [ ] Add Terraform output for API Keys table name and ARN
  - [ ] Write unit tests for APIKey model validation

- [ ] Task 2: Implement API Key Generation and Storage (AC: 1)
  - [ ] Create `APIKeyRepository` in `services/api/src/repositories/api_key_repository.py` with methods: create(), get_by_hash(), update_last_used(), list_by_user(), revoke()
  - [ ] Implement API key generation logic: create UUID key_id, generate random 32-char API key, hash with SHA-256 (never store plaintext)
  - [ ] Store API key metadata in DynamoDB (key_hash, not the actual key)
  - [ ] Configure AWS Secrets Manager to store actual API key (one-time return to user)
  - [ ] Write integration tests for key generation and storage

- [ ] Task 3: Implement Custom Authorizer Lambda Function (AC: 2, 3)
  - [ ] Create custom authorizer Lambda handler in `services/api/src/handlers/auth.py`
  - [ ] Extract API key from request header `X-API-Key`
  - [ ] Hash incoming API key with SHA-256
  - [ ] Query API Keys table via KeyHashIndex to validate key exists and is active
  - [ ] Return IAM policy allowing access if valid, denying if invalid
  - [ ] Pass user_id and key_id to downstream Lambda functions via authorizer context
  - [ ] Log all authorization attempts with correlation IDs
  - [ ] Implement error handling for missing/invalid keys (raise Unauthorized exception)
  - [ ] Write unit tests with mocked DynamoDB lookups
  - [ ] Write integration tests against LocalStack

- [ ] Task 4: Implement Rate Limiting (AC: 4, 5)
  - [ ] Create `RateLimiter` class in `services/api/src/utils/rate_limiter.py`
  - [ ] Implement rate limit tracking using DynamoDB (partition key: key_id, attribute: request_count, ttl: 60 seconds)
  - [ ] Check rate limit before allowing request in custom authorizer
  - [ ] If rate limit exceeded, raise RateLimitError (429 status code)
  - [ ] Ensure rate limit check executes in <10ms (use batch read operations or caching)
  - [ ] Return `Retry-After` header (60 seconds) in rate limit error response
  - [ ] Write unit tests for rate limit calculation and enforcement

- [ ] Task 5: Integrate Custom Authorizer with API Gateway (AC: 2)
  - [ ] Create Terraform module for custom authorizer Lambda function in `infrastructure/terraform/modules/api-gateway/`
  - [ ] Configure API Gateway to use custom authorizer on all routes (except /health)
  - [ ] Set authorizer caching with TTL of 300 seconds (5 minutes) for performance
  - [ ] Add authorizer result caching policy to prevent repeated auth checks
  - [ ] Deploy authorizer to all environments (dev, staging, production)
  - [ ] Verify authorizer is invoked before each endpoint

- [ ] Task 6: Update Error Responses (AC: 3, 5)
  - [ ] Create consistent error response format in `services/api/src/utils/response.py`: {error: {code, message, details, timestamp, request_id}}
  - [ ] Implement 401 Unauthorized response for invalid API keys
  - [ ] Implement 429 Too Many Requests response for rate limit exceeded
  - [ ] Ensure all error responses include request_id (correlation ID) for debugging
  - [ ] Add error response examples to API documentation
  - [ ] Write tests for error response formats

- [ ] Task 7: Create API Key Management Endpoints (AC: 6)
  - [ ] Create `POST /keys` endpoint to generate new API keys (returns key once, then hashed)
  - [ ] Create `GET /keys` endpoint to list user's API keys (without exposing key values)
  - [ ] Create `GET /keys/{key_id}` endpoint to get specific key metadata
  - [ ] Create `DELETE /keys/{key_id}` endpoint to revoke API keys (soft delete via is_active flag)
  - [ ] Create `PATCH /keys/{key_id}` endpoint to update key metadata (name, rate_limit)
  - [ ] Add all endpoints to OpenAPI specification
  - [ ] Implement proper authorization checks (user can only manage their own keys)
  - [ ] Write unit and integration tests for all endpoints

- [ ] Task 8: Implement Frontend Dashboard for API Key Management (AC: 6)
  - [ ] Create React component `apps/developer-dashboard/src/components/ApiKeyList.tsx` to display user's API keys
  - [ ] Create React component `apps/developer-dashboard/src/components/ApiKeyCreateForm.tsx` with form to generate new key
  - [ ] Implement copy-to-clipboard functionality for newly generated API keys
  - [ ] Create modal showing key details (including warning that key won't be shown again)
  - [ ] Create delete/revoke button with confirmation dialog
  - [ ] Create custom hook `apps/developer-dashboard/src/hooks/useApiKeys.ts` using TanStack Query
  - [ ] Add route `/developer/triggers-api/keys` to router
  - [ ] Use shadcn/ui components for consistent styling
  - [ ] Implement proper error handling and loading states
  - [ ] Write component tests using React Testing Library

- [ ] Task 9: Create Audit Logging for Key Operations (AC: 7 implicit)
  - [ ] Create audit log entries when API keys are created (action: "key.created")
  - [ ] Create audit log entries when API keys are used (action: "key.used", updated in custom authorizer)
  - [ ] Create audit log entries when API keys are revoked (action: "key.revoked")
  - [ ] Store audit logs in DynamoDB Audit Logs table (7-year retention)
  - [ ] Include IP address, request ID, and timestamp in audit logs
  - [ ] Write tests for audit log creation

- [ ] Task 10: Update API Documentation (AC: 7)
  - [ ] Add authentication section to OpenAPI spec explaining API key header requirement
  - [ ] Document all authentication error responses (401, 429) in OpenAPI spec
  - [ ] Create "Getting Started" guide: API key generation and usage steps
  - [ ] Create "Authentication" guide explaining X-API-Key header requirement
  - [ ] Create code examples in Python, JavaScript, and cURL showing API key usage
  - [ ] Document rate limiting behavior and retry strategy
  - [ ] Add security best practices section (never commit API keys, rotate keys regularly)
  - [ ] Update Swagger UI to show API key security scheme
  - [ ] Write tests to validate OpenAPI spec completeness

- [ ] Task 11: Verify Integration with Existing Zapier Authentication (IV: 1)
  - [ ] Confirm Triggers API authentication does not break existing Zapier auth system
  - [ ] Ensure API keys are isolated from user authentication (separate system)
  - [ ] Document integration points with existing Zapier auth
  - [ ] Verify that Zapier workflow execution can access events without API keys (internal service-to-service)
  - [ ] Write integration tests confirming existing auth functionality still works

- [ ] Task 12: Ensure Encryption at Rest (IV: 2)
  - [ ] Enable DynamoDB encryption at rest (AWS-managed or KMS) via Terraform
  - [ ] Configure AWS Secrets Manager with encryption for stored API keys
  - [ ] Add KMS key policy allowing Lambda execution role access
  - [ ] Document encryption configuration in ops runbook
  - [ ] Verify encryption is enabled in all environments

- [ ] Task 13: Validate Authorization Performance (<10ms) (IV: 3)
  - [ ] Implement performance benchmarks for custom authorizer
  - [ ] Profile authorizer with CloudWatch X-Ray tracing
  - [ ] Optimize DynamoDB queries (use KeyHashIndex for direct lookups)
  - [ ] Enable authorizer response caching to minimize repeated lookups
  - [ ] Verify p95 authorization latency is <10ms with load testing
  - [ ] Document performance metrics in ops dashboard

- [ ] Task 14: Create Monitoring and Alerting for Auth (AC: 7 implicit)
  - [ ] Create CloudWatch metrics for unauthorized requests (count, rate)
  - [ ] Create CloudWatch metrics for rate-limited requests (count, rate)
  - [ ] Create CloudWatch alarms for spike in unauthorized attempts (potential attack)
  - [ ] Create CloudWatch dashboard widget for auth metrics
  - [ ] Document alert response procedures in incident runbook
  - [ ] Write alerts for anomalous API key usage patterns (if time permits)

- [ ] Task 15: Write Comprehensive Tests (AC: all)
  - [ ] Write unit tests for all authentication functions with 80%+ coverage
  - [ ] Write integration tests for full auth flow (key generation → validation → rate limiting)
  - [ ] Write load tests to validate rate limiting works under load
  - [ ] Write security tests (attempting various attack vectors on auth)
  - [ ] All tests must pass before marking story as Done

---

## Dev Notes

### Previous Story Insights
Story 1.1 (Core Infrastructure) established the foundational AWS infrastructure including API Gateway and Lambda functions. Story 1.2 (Event Ingestion) implemented the POST /events endpoint but without authentication. Story 1.3 builds on this by adding the authentication and authorization layer that protects all API endpoints.

**Key architectural decisions from 1.1:**
- API Gateway is configured with custom authorizers support
- Lambda execution role has DynamoDB access
- All Lambda functions follow Powertools pattern for logging

### Architecture-Specific Technical Details

**Authentication Model:**
The Triggers API implements API key-based authentication (not OAuth 2.0) for simplicity and direct developer access. External developers authenticate using API keys (not user accounts), stored securely in AWS Secrets Manager. This is separate from Zapier's internal user authentication system. [Source: architecture/api-specification.md#security-schemes]

**Custom Authorizer Integration:**
- Deployed as separate Lambda function triggered by API Gateway before business logic execution
- Receives API key from `X-API-Key` header
- Returns IAM policy (Allow/Deny) based on key validity
- Caches authorization decisions (300-second TTL) for performance
- Passes user_id and key_id to downstream functions via authorizer context
[Source: architecture/components.md#5.2-custom-authorizer-service]

**Rate Limiting Strategy:**
- Implemented at custom authorizer level (before expensive DynamoDB operations)
- Uses DynamoDB for distributed rate limit state across Lambda instances
- Default limit: 1000 requests per minute per API key (configurable)
- Rate limit window: 60-second rolling window
- Exceeded requests return 429 Too Many Requests with Retry-After header
[Source: architecture/api-specification.md#REST-API-Specification, prd.md#2.1-functional-requirements-NFR11]

**Data Models:**

**APIKey Model (Pydantic):**
```python
class APIKey(BaseModel):
    key_id: str  # UUID
    user_id: str  # Zapier developer/integration ID
    key_hash: str  # SHA-256 hash (never plaintext)
    name: str  # Human-readable name
    created_at: str  # ISO 8601
    last_used_at: Optional[str]
    expires_at: Optional[str]
    rate_limit: int  # Default: 1000
    is_active: bool
    scopes: List[str]  # e.g., ["events:write", "events:read"]
```
[Source: architecture/data-models.md#3.2-api-key-model]

**DynamoDB API Keys Table Schema:**
- Table: `zapier-triggers-api-keys-{env}`
- PK: user_id (S)
- SK: key_id (S)
- GSI-1: KeyHashIndex (PK: key_hash) for O(1) lookups during auth
- Attributes: key_hash, name, created_at, last_used_at, expires_at, rate_limit, is_active, scopes
- Billing: On-Demand (low write volume, medium read volume)
[Source: architecture/database-schema.md#8.2-dynamodb-api-keys-table]

**API Endpoints (New):**
- `POST /keys` - Generate new API key
- `GET /keys` - List user's keys
- `GET /keys/{key_id}` - Get key details
- `DELETE /keys/{key_id}` - Revoke key
- `PATCH /keys/{key_id}` - Update key metadata

All existing endpoints (`POST /events`, `GET /inbox`, etc.) now require valid API key via custom authorizer.

**File Locations:**
- Backend: `services/api/src/handlers/auth.py` - Custom authorizer handler
- Backend: `services/api/src/services/auth_service.py` - Auth business logic
- Backend: `services/api/src/repositories/api_key_repository.py` - Data access layer
- Backend: `services/api/src/models/api_key.py` - Pydantic models
- Backend: `services/api/src/utils/rate_limiter.py` - Rate limiting logic
- Frontend: `apps/developer-dashboard/src/components/ApiKey*.tsx` - UI components
- Frontend: `apps/developer-dashboard/src/hooks/useApiKeys.ts` - API hooks
- Infrastructure: `infrastructure/terraform/modules/api-gateway/` - Authorizer module
[Source: architecture/unified-project-structure.md]

**Testing Requirements:**
- Unit tests: `services/api/tests/unit/handlers/test_auth.py`, `test_api_key_repository.py`
- Integration tests: `services/api/tests/integration/test_auth_flow.py`
- Frontend tests: `apps/developer-dashboard/tests/unit/hooks/useApiKeys.test.ts`
- Test frameworks: Pytest (backend), Vitest + React Testing Library (frontend)
- Target coverage: 80%+ for unit tests, 60%+ for integration tests
[Source: architecture/testing-strategy.md, coding-standards.md#16.2-naming-conventions]

**Security Considerations:**
- API keys stored as SHA-256 hashes (never plaintext) - one-way function
- Actual key value returned only once during generation (user must save immediately)
- DynamoDB encryption at rest enabled (AWS-managed or KMS)
- Rate limiting prevents brute-force attacks
- Authorization latency must stay <10ms (acceptable overhead per architecture)
- Audit logs created for all key operations (7-year retention for compliance)
[Source: architecture/security-and-performance.md#14.1-security-requirements, prd.md#4.4-deployment-and-operations]

**Performance Targets:**
- Custom authorizer response: <10ms p95 (including DynamoDB lookup)
- Rate limit check: <5ms (DynamoDB on-demand read)
- Authorization caching: 300-second TTL to minimize authorizer invocations
[Source: architecture/components.md#5.2-custom-authorizer-service, iv3-integration-verification]

**Dependencies and Environment:**
- AWS Secrets Manager for API key storage
- DynamoDB for key metadata and rate limit state
- API Gateway for authorizer invocation
- CloudWatch for logging and metrics
- Python 3.11 with Pydantic, boto3
- React 18.2 with TanStack Query, TypeScript
[Source: architecture/tech-stack.md#2.1-technology-stack-table]

### Testing
**Test File Locations:**
- Backend unit tests: `services/api/tests/unit/handlers/test_auth.py`
- Backend integration tests: `services/api/tests/integration/test_auth_flow.py`
- Frontend unit tests: `apps/developer-dashboard/tests/unit/hooks/useApiKeys.test.ts`

**Test Frameworks:**
- Backend: Pytest with pytest-mock, moto for AWS service mocking
- Frontend: Vitest with React Testing Library
- E2E/Load testing: Locust for authentication flow under load

**Key Test Cases:**
- Generate API key and verify SHA-256 hash
- Validate API key via custom authorizer (success and failure paths)
- Test rate limit enforcement (individual key limits)
- Test API key revocation (is_active flag)
- Test 401 Unauthorized response format
- Test 429 Rate Limited response format with Retry-After header
- Frontend: Create API key form validation and submission
- Frontend: Display list of API keys without exposing key values
- Integration: Full flow from key generation through API request authorization

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-11 | 1.0 | Initial story creation with full implementation details from PRD and architecture | Scrum Master |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used
To be filled by dev agent

### Debug Log References
To be filled by dev agent

### Completion Notes
To be filled by dev agent

### File List
To be filled by dev agent

---

## QA Results

*This section will be populated by the QA agent after implementation and testing.*

