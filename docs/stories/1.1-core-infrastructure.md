# Story 1.1: Set Up Core Infrastructure and Development Environment

## Status

Ready for Development

---

## Story

**As a** DevOps Engineer,
**I want** to establish the foundational AWS infrastructure and development environment,
**so that** the development team can build and deploy the Triggers API components.

---

## Acceptance Criteria

1. Terraform configuration created for AWS resources (VPC, API Gateway, Lambda, DynamoDB)
2. CI/CD pipeline established with automated testing stages
3. Development, staging, and production environments provisioned
4. Infrastructure deployed successfully to dev environment
5. Health check endpoint returns 200 OK
6. Documentation created for local development setup

---

## Integration Verification

- **IV1**: Terraform plan executes without errors in all environments
- **IV2**: CI/CD pipeline successfully deploys to dev environment
- **IV3**: AWS resource tags and naming conventions match organizational standards

---

## Tasks / Subtasks

### Core Infrastructure Setup (AC: 1, 3, 4)

- [ ] **Create VPC and Networking Infrastructure**
  - [ ] Define VPC with CIDR block 10.0.0.0/16
  - [ ] Create public subnets across 2 AZs (10.0.1.0/24, 10.0.2.0/24)
  - [ ] Create private subnets across 2 AZs (10.0.10.0/24, 10.0.11.0/24)
  - [ ] Configure Internet Gateway and NAT Gateway for internet access
  - [ ] Create security groups for Lambda and API Gateway
  - [ ] Document VPC architecture in infrastructure/terraform/modules/vpc/README.md

- [ ] **Set Up DynamoDB Tables**
  - [ ] Create Events table (zapier-triggers-api-events-dev) with partition key user_id, sort key timestamp#event_id
  - [ ] Create API Keys table (zapier-triggers-api-keys-dev) with partition key user_id, sort key key_id
  - [ ] Create Audit Logs table (zapier-triggers-api-audit-logs-dev) with partition key user_id, sort key timestamp#log_id
  - [ ] Configure Global Secondary Indexes (GSI) for efficient queries:
    - Events table: EventTypeIndex (user_id, event_type#timestamp), StatusIndex (user_id, status#timestamp)
    - API Keys table: KeyHashIndex (key_hash)
  - [ ] Enable TTL on Events table (30 days) and Audit Logs table (7 years)
  - [ ] Configure on-demand billing mode with auto-scaling
  - [ ] Enable point-in-time recovery for disaster recovery
  - [ ] Enable DynamoDB Streams for event notifications

- [ ] **Set Up SQS Queues**
  - [ ] Create main event queue (zapier-triggers-events-dev) with 15-minute visibility timeout
  - [ ] Create dead-letter queue (zapier-triggers-events-dlq-dev) with 14-day retention
  - [ ] Configure queue visibilityTimeout and messageRetentionPeriod
  - [ ] Enable CloudWatch alarms for queue depth monitoring
  - [ ] Document queue configuration and message structure

- [ ] **Set Up API Gateway and Lambda Integration**
  - [ ] Create API Gateway REST API (zapier-triggers-api-dev)
  - [ ] Configure API stages: dev, staging, production
  - [ ] Create custom authorizer Lambda function
  - [ ] Set up resource routes: /events, /inbox, /health
  - [ ] Configure request/response mappings
  - [ ] Enable CloudWatch logging for all API requests
  - [ ] Configure CORS policy to allow Zapier origins
  - [ ] Document API Gateway configuration

- [ ] **Set Up Secrets Manager and Parameters**
  - [ ] Create Secrets Manager secret for API keys (zapier-triggers-api/api-keys-dev)
  - [ ] Create Parameter Store entries for environment configuration
  - [ ] Set up secure credential rotation policies
  - [ ] Document secrets management procedures

### Terraform Infrastructure as Code (AC: 1, 4)

- [ ] **Create Terraform Project Structure**
  - [ ] Initialize Terraform backend (S3 + DynamoDB for state locking)
  - [ ] Create directory structure:
    - infrastructure/terraform/modules/ (VPC, Lambda, DynamoDB, SQS, API Gateway, Monitoring)
    - infrastructure/terraform/environments/ (dev, staging, production)
  - [ ] Create root main.tf, variables.tf, outputs.tf, backend.tf
  - [ ] Create environment-specific terraform.tfvars files
  - [ ] Document Terraform conventions and variable naming

- [ ] **Create Reusable Terraform Modules**
  - [ ] VPC module (networking, subnets, security groups)
  - [ ] DynamoDB module (table creation, indexes, TTL, streams)
  - [ ] SQS module (queue creation, DLQ configuration, alarms)
  - [ ] API Gateway module (REST API, stages, custom authorizer)
  - [ ] Lambda module (function creation, IAM roles, environment variables)
  - [ ] Monitoring module (CloudWatch dashboards, alarms, X-Ray tracing)
  - [ ] Each module with variables.tf, outputs.tf, main.tf, and README.md

- [ ] **Configure Environment-Specific Deployments**
  - [ ] Create dev/main.tf with dev-specific configurations
  - [ ] Create staging/main.tf with staging-specific configurations
  - [ ] Create production/main.tf with production-specific configurations
  - [ ] Implement tagging strategy for all resources (Environment, Project, CostCenter)
  - [ ] Configure resource naming conventions (kebab-case with environment suffix)
  - [ ] Validate Terraform formatting and best practices

- [ ] **Document Terraform Configuration**
  - [ ] Create infrastructure/terraform/README.md with setup instructions
  - [ ] Document module purposes and usage
  - [ ] Create ARCHITECTURE.md explaining infrastructure decisions
  - [ ] Add variable descriptions for all Terraform variables
  - [ ] Document backend configuration and state management

### CI/CD Pipeline Setup (AC: 2, 4)

- [ ] **Create GitHub Actions Workflows**
  - [ ] Create .github/workflows/ci.yaml:
    - Trigger on push to develop, PR to main
    - Backend tests (Python unit + integration tests with pytest)
    - Frontend tests (TypeScript unit tests with vitest)
    - Linting and formatting checks (Black, Flake8, ESLint, Prettier)
    - Type checking (mypy for Python, TypeScript compiler)
    - Security scanning (dependency vulnerabilities with Snyk)
    - Terraform plan validation (terraform fmt, validate, plan)
  - [ ] Create .github/workflows/deploy-staging.yaml:
    - Trigger on push to develop or manual dispatch
    - Run CI tests (skip if PR checks already passed)
    - Deploy Terraform changes to staging environment
    - Build and push Lambda function containers
    - Build frontend and deploy to CloudFront
    - Run post-deployment health checks
  - [ ] Create .github/workflows/deploy-production.yaml:
    - Trigger on push to main or manual dispatch with approval
    - Run all CI tests
    - Deploy Terraform changes to production
    - Deploy Lambda with canary rollout (5% → 25% → 100%)
    - Deploy frontend with CloudFront invalidation
    - Run post-deployment smoke tests

- [ ] **Configure Automated Testing in Pipeline**
  - [ ] Set up pytest with coverage requirements (>80% for backend)
  - [ ] Set up vitest with coverage requirements (>60% for frontend)
  - [ ] Create test fixtures and mocks for AWS services (moto)
  - [ ] Configure LocalStack integration for E2E testing
  - [ ] Document test coverage requirements in TESTING.md

- [ ] **Configure Deployment Automation**
  - [ ] Set up AWS credentials in GitHub Secrets
  - [ ] Configure Terraform Cloud/S3 backend for state management
  - [ ] Create deployment scripts:
    - infrastructure/scripts/deploy.sh (run terraform apply)
    - infrastructure/scripts/rollback.sh (rollback to previous version)
  - [ ] Set up environment-specific deployment configurations
  - [ ] Document deployment procedures in runbooks/deployment.md

### Health Check Endpoint (AC: 5)

- [ ] **Create Health Check Handler**
  - [ ] Create src/handlers/health.py Lambda handler
  - [ ] Return 200 OK with status: "healthy"
  - [ ] Include API version and timestamp in response
  - [ ] Perform basic dependency checks (DynamoDB connectivity)
  - [ ] Add CloudWatch metrics for health check invocations
  - [ ] Write unit tests in tests/unit/handlers/test_health.py

- [ ] **Set Up Health Check Endpoint**
  - [ ] Create GET /health route in API Gateway
  - [ ] Disable authentication for health check (security group: [])
  - [ ] Configure CloudWatch alarms for failed health checks
  - [ ] Document health check endpoint in API documentation

### Local Development Environment (AC: 6)

- [ ] **Create Development Setup Documentation**
  - [ ] Create scripts/setup-dev.sh with automated setup steps
  - [ ] Document prerequisites: Python 3.11, Node.js 18, AWS CLI, Terraform, Docker
  - [ ] Document environment variable setup (.env.example)
  - [ ] Document local testing with LocalStack or DynamoDB Local
  - [ ] Create README.md for local development workflow
  - [ ] Document troubleshooting common setup issues

- [ ] **Set Up Local AWS Service Simulation**
  - [ ] Create docker-compose.yml for LocalStack (DynamoDB, SQS, Secrets Manager)
  - [ ] Document local deployment commands using AWS CLI
  - [ ] Create test data seeding scripts (scripts/seed-data.sh)
  - [ ] Document how to connect local services with Terraform

- [ ] **Create Development Environment Configuration**
  - [ ] Create .env.example with all required variables
  - [ ] Document variable meanings and example values
  - [ ] Create environment-specific .env files (dev.env, staging.env, prod.env)
  - [ ] Add .env files to .gitignore for security

---

## Dev Notes

### Technical Context from Architecture Document

**Infrastructure Stack (from docs/architecture.md section 1.2):**
- Primary Region: us-east-1 (N. Virginia) for Phase 1
- Multi-AZ deployment required for high availability
- Services: Lambda, API Gateway, DynamoDB, SQS, S3, CloudWatch, X-Ray, Secrets Manager, Parameter Store
- VPC deployment with private/public subnets for network isolation

**Naming Conventions:**
- AWS resources: kebab-case with project prefix and environment suffix
  - Example: `zapier-triggers-api-events-dev`, `zapier-triggers-api-keys-dev`
- Lambda functions: Should follow naming pattern `zapier-triggers-api-{function-name}-{env}`
- Environment variables: UPPER_SNAKE_CASE (AWS_REGION, DYNAMODB_TABLE_NAME, etc.)

**DynamoDB Design (from section 8):**
- Events table partition key: user_id; sort key: timestamp#event_id (composite for chronological ordering)
- API Keys table partition key: user_id; sort key: key_id
- Audit Logs table partition key: user_id; sort key: timestamp#log_id
- Global Secondary Indexes must be created for efficient querying by event_type and status
- TTL required: 30 days for Events, 7 years for Audit Logs

**API Gateway Configuration:**
- Custom authorizer Lambda validates API keys from Secrets Manager
- All API calls require X-API-Key header authentication (except /health)
- API versioning: /v1/ endpoint prefix
- Rate limiting: 1000 requests/minute per API key (enforced in authorizer)

**Terraform Best Practices:**
- Use modules for reusability across environments
- Implement comprehensive tagging strategy
- Store state in S3 with DynamoDB locking
- Use terraform.tfvars for environment-specific values
- Document all variables with descriptions and validation rules

**CI/CD Requirements:**
- GitHub Actions as primary CI/CD platform
- Automated tests before deployment to all environments
- Blue-green deployment for Lambda (using versions and aliases)
- Canary deployment: 5% → 25% → 100% traffic rollout
- Automatic rollback on error rate >1% for 5 minutes

### Project Structure Reference

```
infrastructure/
├── terraform/
│   ├── modules/
│   │   ├── api-gateway/
│   │   ├── dynamodb/
│   │   ├── lambda/
│   │   ├── networking/
│   │   ├── sqs/
│   │   └── monitoring/
│   ├── environments/
│   │   ├── dev/
│   │   ├── staging/
│   │   └── production/
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf
│   └── backend.tf
├── scripts/
│   ├── deploy.sh
│   └── rollback.sh
└── README.md

services/api/
├── src/
│   ├── handlers/
│   │   ├── events.py
│   │   ├── inbox.py
│   │   ├── acknowledgment.py
│   │   ├── auth.py
│   │   └── health.py
│   └── config.py
├── tests/
│   ├── unit/
│   └── integration/
└── pyproject.toml

.github/workflows/
├── ci.yaml
├── deploy-staging.yaml
└── deploy-production.yaml
```

### Integration Points with Other Stories

- **Story 1.2 (Event Ingestion)** depends on: DynamoDB Events table, SQS queue, Lambda execution environment, API Gateway configuration
- **Story 1.3 (Authentication)** depends on: Secrets Manager setup, Custom Authorizer Lambda, API Keys table
- **Story 1.4 (Event Storage)** depends on: DynamoDB Events table with correct schema and indexes
- **Story 1.8 (Monitoring)** depends on: CloudWatch configuration from this story

### Security Considerations

- All database credentials must be stored in AWS Secrets Manager, never in code
- VPC deployment ensures Lambda functions can only access private DynamoDB without internet exposure
- API Gateway custom authorizer validates all requests before reaching Lambda
- Enable TLS 1.3 on all API Gateway endpoints
- Implement resource-based policies for cross-service access

### Performance Targets

- Health check response time: <50ms
- Terraform plan execution: <5 minutes
- CI/CD pipeline completion: <20 minutes (including tests)
- Initial DynamoDB provisioning: on-demand billing mode for auto-scaling
- Lambda cold start optimization: functions should be <500MB for quick initialization

---

## Dev Notes - Testing Standards

### Testing Framework and Location

**Backend Testing:**
- Framework: pytest 7.4+
- Location: `services/api/tests/`
- Structure: unit/, integration/, load/
- Command: `cd services/api && poetry run pytest --cov=src --cov-report=html`
- Coverage Target: >80% for unit tests

**Terraform Testing:**
- Tool: terraform validate, terraform fmt (linting)
- Command: `cd infrastructure/terraform && terraform validate && terraform fmt -recursive`
- No automated unit tests for Terraform in this story (manual review sufficient for initial setup)

**CI/CD Testing:**
- Framework: GitHub Actions
- Trigger: All pull requests and pushes to main/develop branches
- Must pass before merging

### Specific Testing Requirements for This Story

1. **Infrastructure Tests:**
   - Terraform plan must execute without errors/warnings
   - Validate all required resources are created
   - Verify security group rules are restrictive
   - Confirm IAM policies follow least-privilege principle
   - Check resource tags match organizational standards

2. **Health Check Tests:**
   - Unit test: Test 200 OK response with required fields
   - Integration test: Deploy to dev and verify health check succeeds
   - Load test: Confirm health check handles high request volume

3. **Environment Tests:**
   - Validate environment variables are set correctly
   - Test local setup script runs without errors
   - Verify DynamoDB connectivity from Lambda
   - Confirm SQS queue is accessible

4. **Documentation Tests:**
   - README must contain setup instructions
   - All code must have docstrings
   - Terraform variables must have descriptions
   - Example .env file must be complete

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-11 | 1.0 | Initial story creation with full AC, tasks, and dev notes | Scrum Master |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

[To be filled during implementation]

### Debug Log References

[To be filled during implementation]

### Completion Notes List

[To be filled during implementation]

### File List

[To be filled during implementation]

---

## QA Results

*This section will be populated by the QA agent after development completion.*

[QA results to be added]

---

**Story Document Status**: Ready for Development
**Estimated Effort**: 40-48 hours (5-6 days for experienced DevOps engineer)
**Dependencies**: None - foundational story
**Blocks**: All subsequent stories in Epic 1
